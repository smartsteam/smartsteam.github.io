<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-STEAM 교육 By Kim Hwang</title>
    <style>
        /* Base Styles */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; background-color: #f4f7f6; color: #333; }
        h1 { color: #2c3e50; margin-bottom: 30px; }
        .controls { display: flex; gap: 20px; margin-bottom: 30px; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); align-items: center; flex-wrap: wrap; justify-content: center; }
        button { padding: 12px 25px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; transition: background-color 0.3s ease, transform 0.2s ease; }
        button:hover { transform: translateY(-2px); }
        #connectButton { background-color: #28a745; color: white; }
        #disconnectButton { background-color: #dc3545; color: white; display: none; }
        #startButton { background-color: #007bff; color: white; }
        #stopButton { background-color: #ffc107; color: #333; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        .slider-container { display: flex; align-items: center; gap: 10px; font-weight: bold; color: #555; }
        #rowCountSlider { width: 150px; cursor: pointer; }
        #rowCountValue { min-width: 30px; text-align: right; }
        .controls-group { display: flex; align-items: center; gap: 10px; }
        .controls-group input[type="number"] { width: 70px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .controls-group label { font-weight: bold; }
        
        /* -- Main Layout Container -- */
        .data-layout-container {
            display: flex;
            gap: 15px;
            width: 95%;
            max-width: 1600px;
            align-items: flex-start;
        }

        /* -- Panel Styles (Shared) -- */
        /* This style is now applied to individual panels */
        .panel {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* -- Left Panel (Live Data Table) -- */
        .data-table-panel {
            flex: 0 0 30%; /* Set a fixed width of 30% of the container */
            height: 600px; /* Adjust height as needed */
        }
        
        /* -- Right Container (Charts & Stats Table) -- */
        .charts-and-stats-container {
            flex: 1; /* Take up the remaining space */
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 600px; /* Match the height of the left panel */
        }
        
        /* -- Stats Table Panel -- */
        .stats-table-panel { /* New class for the stats table background */
            flex-shrink: 0;
            /* Apply panel styles here */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
        }

        /* -- Chart Display Container -- */
        .data-display-container {
            display: flex;
            flex-wrap: nowrap;
            gap: 15px;
            width: 100%; /* Take up the full width of its parent */
            align-items: flex-start;
            user-select: none;
        }

        /* -- Chart Panels -- */
        .resizable-panel {
            min-width: 250px;
            height: 400px; /* Fixed height for charts, can be adjusted by slider */
            overflow: hidden;
            flex-grow: 1; /* Distribute space equally */
            flex-basis: 0;
            display: flex;
            /* Now, this acts as the panel with a background */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            border-radius: 8px;
        }
        
        .chart-inner-panel {
            /* Removed redundant styles, as .resizable-panel now has the background */
            padding: 20px;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* --- Tables --- */
        .table-container {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .table-container::-webkit-scrollbar {
            display: none;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            table-layout: fixed;
        }
        .stats-table {
            margin-top: 0;
            width: 100%;
        }
        /* All table headers and cells are now centered */
        th, td { 
            padding: 12px 15px; 
            text-align: center; /* Adjusted for center alignment */
            border-bottom: 1px solid #eee; 
        }
        th { background-color: #e9ecef; color: #495057; font-weight: bold; }
        th[contenteditable="true"] { cursor: text; outline: 2px solid transparent; transition: outline 0.1s ease-in-out; }
        th[contenteditable="true"]:hover { outline: 2px solid #a0c4ff; }
        th[contenteditable="true"]:focus { outline: 2px solid #007bff; }


        tr:nth-child(even) { background-color: #f8f9fa; }
        tr:hover { background-color: #e2f0ff; }
        
        /* --- Chart Containers --- */
        .chart-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Added for positioning the gauge label */
        }
        .chart-container canvas { width: 100% !important; height: 100% !important; }
        
        /* --- Gauge Chart Specifics --- */
        .gauge-label {
            position: absolute;
            font-size: 2.5rem;
            font-weight: bold;
            color: #333;
            /* Adjusted position to be relative to the chart container */
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-gauge@1.0.1"></script>
</head>
<body>
    <h1>AI-STEAM 교육 [디지털 과학실험]</h1>

    <div class="controls">
        <button id="connectButton">장치 연결</button>
        <button id="disconnectButton">연결 해제</button>
        <button id="startButton" disabled>시작</button>
        <button id="stopButton" disabled>정지</button>
        <div class="slider-container">
            표시 행 수: <span id="rowCountValue">50</span>
            <input type="range" id="rowCountSlider" min="10" max="100" step="10" value="50">
        </div>
        <div class="controls-group">
            <input type="checkbox" id="manualScaleToggle">
            <label for="manualScaleToggle">Y축 수동 설정</label>
            <div id="manualScaleInputs" style="display: none;">
                최소: <input type="number" id="yMinInput" value="0">
                최대: <input type="number" id="yMaxInput" value="1024">
            </div>
        </div>
    </div>

    <div class="data-layout-container">
        <div class="data-table-panel panel">
            <h2>데이터</h2>
            <div class="table-container">
                <table id="dataTable">
                    <thead id="dataTableHead">
                        <tr>
                            <th>순번</th>
                            <th>시각</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody"></tbody>
                </table>
            </div>
        </div>

        <div class="charts-and-stats-container">
            <div class="stats-table-panel panel">
                <h2>통계</h2>
                <table id="statsTable" class="stats-table">
                    <thead>
                        <tr>
                            <th>항목</th>
                            <th>수집 데이터 갯수</th>
                            <th>최근 값</th>
                            <th>평균 값</th>
                            <th>최대 값</th>
                            <th>최소 값</th>
                        </tr>
                    </thead>
                    <tbody id="statsTableBody">
                        </tbody>
                </table>
            </div>

            <div class="data-display-container">
                <div class="resizable-panel" id="lineChartPanel">
                    <div class="chart-inner-panel">
                        <h2>라인 그래프</h2>
                        <div class="chart-container">
                            <canvas id="lineChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
        
                <div class="resizable-panel" id="barChartPanel">
                    <div class="chart-inner-panel">
                        <h2>막대 그래프</h2>
                        <div class="chart-container">
                            <canvas id="barChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
        
                <div class="resizable-panel" id="gaugeChartPanel">
                    <div class="chart-inner-panel">
                        <h2 id="gaugeChartTitle">게이지그래프 (센서1)</h2>
                        <div class="chart-container">
                            <canvas id="gaugeChartCanvas"></canvas>
                            <div id="gaugeLabel" class="gauge-label">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const connectButton = document.getElementById('connectButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const rowCountSlider = document.getElementById('rowCountSlider');
        const rowCountValue = document.getElementById('rowCountValue');
        const manualScaleToggle = document.getElementById('manualScaleToggle');
        const manualScaleInputs = document.getElementById('manualScaleInputs');
        const yMinInput = document.getElementById('yMinInput');
        const yMaxInput = document.getElementById('yMaxInput');
        const dataTableHead = document.getElementById('dataTableHead');
        const dataTableBody = document.getElementById('dataTableBody');
        const statsTableBody = document.getElementById('statsTableBody');
        const lineChartCanvas = document.getElementById('lineChartCanvas');
        const barChartCanvas = document.getElementById('barChartCanvas');
        const gaugeChartCanvas = document.getElementById('gaugeChartCanvas');
        const gaugeLabel = document.getElementById('gaugeLabel');
        const gaugeChartTitle = document.getElementById('gaugeChartTitle');


        let port;
        let reader;
        let reading = false; // Flag to control the reading loop
        let rowLimit = parseInt(rowCountSlider.value);
        let sequenceNumber = 1;
        let sensorCount = 0;
        let sensorData = []; // To store ALL collected data for cumulative stats
        let sensorNames = []; // Array to store custom sensor names
        
        let lineChart;
        let barChart;
        let gaugeChart;
        
        let lineChartColors = [
            'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)',
            'rgb(153, 102, 255)', 'rgb(201, 203, 207)', 'rgb(255, 159, 64)', 'rgb(120, 180, 50)'
        ];

        // Chart.js 인스턴스 초기화
        function initCharts() {
            if (lineChart) lineChart.destroy();
            if (barChart) barChart.destroy();
            if (gaugeChart) gaugeChart.destroy();

            // 라인 차트 초기화 (데이터셋은 동적으로 추가)
            lineChart = new Chart(lineChartCanvas, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            title: { display: true, text: '수집 시각' }
                        },
                        y: {
                            title: { display: true, text: '데이터' },
                            beginAtZero: true,
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });

            // 막대 그래프 초기화
            barChart = new Chart(barChartCanvas, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: '최근 입력 데이터',
                        data: [],
                        backgroundColor: [],
                        borderColor: [],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: '센서' }
                        },
                        y: {
                            title: { display: true, text: '데이터' },
                            beginAtZero: true,
                        }
                    }
                }
            });
            
            // 게이지 차트 초기화 (도넛 차트 활용)
            gaugeChart = new Chart(gaugeChartCanvas, {
                type: 'doughnut',
                data: {
                    labels: ['Current', 'Remaining'],
                    datasets: [{
                        data: [0, 1024],
                        backgroundColor: ['rgb(0, 150, 136)', 'rgb(220, 220, 220)'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    circumference: 180,
                    rotation: 270,
                    cutout: '50%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                }
            });
            
            applyChartScaleSettings(); // 초기 스케일 설정 적용
        }
        
        // 테이블 헤더 업데이트 함수 (센서 개수에 따라 동적 생성)
        function updateTableHeader(count) {
            if (sensorCount !== count) {
                // Initialize or resize sensorNames array
                if (sensorNames.length !== count) {
                    const oldNames = [...sensorNames];
                    sensorNames = Array(count).fill(null).map((_, i) => oldNames[i] || `센서${i + 1}`);
                }

                // Live Data Table Header
                const dataHeaderRow = dataTableHead.querySelector('tr');
                // Remove existing sensor headers
                while (dataHeaderRow.children.length > 2) {
                    dataHeaderRow.removeChild(dataHeaderRow.lastChild);
                }
                // Add new sensor headers
                sensorNames.forEach((name, i) => {
                    const newHeader = document.createElement('th');
                    newHeader.textContent = name;
                    newHeader.setAttribute('contenteditable', 'true');
                    newHeader.dataset.sensorIndex = i; // Store index for later reference
                    newHeader.addEventListener('blur', handleSensorNameEdit);
                    newHeader.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault(); // Prevent new line in contenteditable
                            e.target.blur(); // Trigger blur to save changes
                        }
                    });
                    dataHeaderRow.appendChild(newHeader);
                });
                
                // Stats Table Body (re-create rows for each sensor)
                statsTableBody.innerHTML = ''; // Clear previous rows
                sensorNames.forEach((name, i) => {
                    const newRow = statsTableBody.insertRow();
                    newRow.innerHTML = `
                        <td>${name}</td>
                        <td id="stats-count-${i}">0</td>
                        <td id="stats-latest-${i}">---</td>
                        <td id="stats-avg-${i}">---</td>
                        <td id="stats-max-${i}">---</td>
                        <td id="stats-min-${i}">---</td>
                    `;
                });
                
                sensorCount = count;
                // Initialize the sensorData array to store data for calculations
                sensorData = Array.from({ length: sensorCount }, () => []);
            }
        }

        // Handle sensor name edit
        function handleSensorNameEdit(event) {
            const index = parseInt(event.target.dataset.sensorIndex);
            const newName = event.target.textContent.trim();
            if (newName && sensorNames[index] !== newName) {
                sensorNames[index] = newName;
                console.log(`Sensor ${index + 1} name changed to: ${newName}`);
                
                // Update Line Chart legend
                if (lineChart && lineChart.data.datasets[index]) {
                    lineChart.data.datasets[index].label = newName;
                }

                // Update Bar Chart labels
                if (barChart && barChart.data.labels[index] !== undefined) {
                    barChart.data.labels[index] = newName;
                }
                
                // Update Stats Table row label
                const statsRow = statsTableBody.rows[index];
                if (statsRow) {
                    statsRow.cells[0].textContent = newName;
                }

                // Update Gauge Chart title if it's for the first sensor
                if (index === 0) {
                    gaugeChartTitle.textContent = `게이지 차트 (${newName})`;
                }

                lineChart.update();
                barChart.update();
                gaugeChart.update(); // Update gauge chart to reflect title change (though not directly data related)
            } else if (!newName) {
                // If the user clears the name, revert to the default
                event.target.textContent = sensorNames[index];
            }
        }

        // Y축 스케일 설정 적용 함수
        function applyChartScaleSettings() {
            const yMin = parseFloat(yMinInput.value);
            const yMax = parseFloat(yMaxInput.value);
            
            if (manualScaleToggle.checked && !isNaN(yMin) && !isNaN(yMax)) {
                lineChart.options.scales.y.min = yMin;
                lineChart.options.scales.y.max = yMax;
                barChart.options.scales.y.min = yMin;
                barChart.options.scales.y.max = yMax;
                console.log(`Y-axis scale manually set to [${yMin}, ${yMax}]`);
            } else {
                delete lineChart.options.scales.y.min;
                delete lineChart.options.scales.y.max;
                delete barChart.options.scales.y.min;
                delete barChart.options.scales.y.max;
                console.log('Y-axis scale reverted to auto mode');
            }
            
            const gaugeMaxValue = manualScaleToggle.checked ? yMax : 1024;
            gaugeChart.data.datasets[0].data[1] = gaugeMaxValue - gaugeChart.data.datasets[0].data[0];
            
            lineChart.update('none');
            barChart.update('none');
            gaugeChart.update('none');
        }

        // 통계 데이터 계산 및 업데이트 함수
        function updateStatsTable(dataValues) {
            dataValues.forEach((value, index) => {
                const dataValue = parseFloat(value);
                if (!isNaN(dataValue)) {
                    // Push data to the cumulative array
                    if (!sensorData[index]) {
                         sensorData[index] = [];
                    }
                    sensorData[index].push(dataValue);

                    const data = sensorData[index];
                    const count = data.length;
                    const latest = data[data.length - 1];
                    const sum = data.reduce((a, b) => a + b, 0);
                    const avg = sum / count;
                    const max = Math.max(...data);
                    const min = Math.min(...data);

                    document.getElementById(`stats-count-${index}`).textContent = count;
                    document.getElementById(`stats-latest-${index}`).textContent = latest.toFixed(2);
                    document.getElementById(`stats-avg-${index}`).textContent = avg.toFixed(2);
                    document.getElementById(`stats-max-${index}`).textContent = max.toFixed(2);
                    document.getElementById(`stats-min-${index}`).textContent = min.toFixed(2);
                }
            });
        }

        // 슬라이더 값 변경 시 이벤트 리스너
        rowCountSlider.addEventListener('input', (event) => {
            rowLimit = parseInt(event.target.value);
            rowCountValue.textContent = rowLimit;
            // Trim the chart data immediately when the slider is changed
            while (lineChart.data.labels.length > rowLimit) {
                lineChart.data.labels.shift();
                lineChart.data.datasets.forEach(dataset => dataset.data.shift());
            }
            lineChart.update();
        });
        
        // Y축 수동 설정 토글 이벤트 리스너
        manualScaleToggle.addEventListener('change', () => {
            manualScaleInputs.style.display = manualScaleToggle.checked ? 'flex' : 'none';
            applyChartScaleSettings();
        });
        
        // Y축 수동 설정 입력 필드 이벤트 리스너
        yMinInput.addEventListener('input', applyChartScaleSettings);
        yMaxInput.addEventListener('input', applyChartScaleSettings);

        // "장치 연결" 버튼 클릭 이벤트
        connectButton.addEventListener('click', async () => {
            try {
                port = await navigator.serial.requestPort();
                const fixedBaudRate = 115200; // Fixed baud rate
                await port.open({ baudRate: fixedBaudRate });

                connectButton.style.display = 'none';
                disconnectButton.style.display = 'inline-block';
                startButton.disabled = false;
                stopButton.disabled = true;

                console.log('시리얼 포트 연결됨:', port);

            } catch (error) {
                console.error('시리얼 포트 연결 오류:', error);
                alert('시리얼 포트 연결에 실패했습니다. 장치를 확인하거나 권한을 허용해주세요.');
            }
        });

        // "연결 해제" 버튼 클릭 이벤트
        disconnectButton.addEventListener('click', async () => {
            if (reading) {
                // If reading is active, cancel the reader and set reading to false
                reading = false;
                if (reader) {
                    await reader.cancel();
                    reader.releaseLock();
                    reader = null;
                }
            }
            if (port) {
                try {
                    await port.close();
                    port = null;
                    console.log('시리얼 포트 연결 해제됨');
                    connectButton.style.display = 'inline-block';
                    disconnectButton.style.display = 'none';
                    startButton.disabled = true;
                    stopButton.disabled = true;
                } catch (error) {
                    console.error('시리얼 포트 연결 해제 오류:', error);
                    alert('시리얼 포트 연결 해제에 실패했습니다.');
                }
            }
        });

        // "시작" 버튼 클릭 이벤트
        startButton.addEventListener('click', () => {
            startReading();
            startButton.disabled = true;
            stopButton.disabled = false;
        });

        // "정지" 버튼 클릭 이벤트
        stopButton.addEventListener('click', async () => {
            // This function now only pauses the reading loop, keeping the port open
            if (reading) {
                reading = false;
                // Don't release the lock, just cancel the read() call
                if (reader) {
                    await reader.cancel();
                }
            }
            console.log('데이터 수집 정지 요청됨.');
            startButton.disabled = false;
            stopButton.disabled = true;
        });

        // 데이터 수집 시작 함수
        async function startReading() {
            if (!port || reading) return;
            reading = true;
            if (!reader) {
                reader = port.readable.getReader();
            }
            
            console.log('데이터 수집 시작...');
            let buffer = '';
            try {
                while (reading) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += new TextDecoder().decode(value);
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    lines.forEach(line => {
                        const trimmedLine = line.trim();
                        if (trimmedLine) updateTableAndCharts(trimmedLine);
                    });
                }
            } catch (error) {
                console.error('데이터 읽기 오류:', error);
                if (reading) { stopReading(); alert('데이터 읽기 중 오류가 발생하여 수집을 중지합니다.'); }
            } finally {
                // The reader is only released if the port is closed or an error occurs
                // If it's just paused by the user, the lock is kept
                if (!reading && reader) {
                    reader.releaseLock();
                    reader = null;
                }
                console.log('데이터 수집 종료.');
            }
        }
        
        // 테이블 및 차트 업데이트 함수
        function updateTableAndCharts(data) {
            const now = new Date();
            // 24시간 형식으로 시, 분, 초, 1/100초를 표현
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const milliseconds = String(Math.floor(now.getMilliseconds() / 10)).padStart(2, '0'); // Get hundredths of a second
            const timeString = `${hours}:${minutes}:${seconds}.${milliseconds}`;
            
            const dataValues = data.split(',').map(value => parseFloat(value.trim()));
            
            // Update table headers based on the number of sensors
            updateTableHeader(dataValues.length); // This also updates sensorNames if needed

            const newRow = dataTableBody.insertRow(0); // Insert at the top
            newRow.insertCell(0).textContent = sequenceNumber++;
            newRow.insertCell(1).textContent = timeString;
            
            // Add new datasets to the line chart if needed and update data
            for (let i = 0; i < dataValues.length; i++) {
                if (lineChart.data.datasets.length <= i) { // Prevent adding duplicates
                    const colorIndex = i % lineChartColors.length;
                    lineChart.data.datasets.push({
                        label: sensorNames[i], // Use custom sensor name
                        data: [],
                        borderColor: lineChartColors[colorIndex],
                        tension: 0.1,
                        fill: false
                    });
                }
            }
            
            lineChart.data.labels.push(timeString);
            dataValues.forEach((value, index) => {
                const dataValue = parseFloat(value);
                newRow.insertCell(index + 2).textContent = value;
                
                if (!isNaN(dataValue)) {
                    lineChart.data.datasets[index].data.push(dataValue);
                } else {
                    lineChart.data.datasets[index].data.push(NaN);
                }
            });
            
            // Update Stats Table (Cumulative)
            updateStatsTable(dataValues);

            // Update Bar Chart
            const barChartLabels = sensorNames.slice(0, dataValues.length); // Use custom sensor names
            barChart.data.labels = barChartLabels;
            barChart.data.datasets[0].data = dataValues;
            barChart.data.datasets[0].backgroundColor = barChart.data.datasets[0].data.map((_, index) => lineChartColors[index % lineChartColors.length]);
            barChart.data.datasets[0].borderColor = barChart.data.datasets[0].backgroundColor;

            // Update Gauge Chart with the first sensor's value and title
            const firstSensorValue = dataValues[0];
            if (!isNaN(firstSensorValue)) {
                 const gaugeMaxValue = manualScaleToggle.checked ? parseFloat(yMaxInput.value) : 1024;
                 const clampedValue = Math.min(Math.max(firstSensorValue, 0), gaugeMaxValue);
                 gaugeChart.data.datasets[0].data = [clampedValue, gaugeMaxValue - clampedValue];
                 gaugeLabel.textContent = firstSensorValue;
            } else {
                 gaugeChart.data.datasets[0].data = [0, 1024];
                 gaugeLabel.textContent = '---';
            }
            gaugeChartTitle.textContent = `게이지 차트 (${sensorNames[0] || '센서 1'})`;


            // Remove old data from live data table and charts
            while (dataTableBody.children.length > rowLimit) {
                dataTableBody.removeChild(dataTableBody.lastChild); // Remove from the bottom
            }

            while (lineChart.data.labels.length > rowLimit) {
                lineChart.data.labels.shift();
                lineChart.data.datasets.forEach(dataset => dataset.data.shift());
            }

            // Update charts
            lineChart.update();
            barChart.update();
            gaugeChart.update();
        }
        
        // 페이지 로드 시 초기 설정
        window.addEventListener('load', () => {
            initCharts();
            // Initial height for charts, now fixed
            document.querySelectorAll('.resizable-panel').forEach(container => {
                container.style.height = `400px`;
            });
        });
    </script>
</body>
</html>
