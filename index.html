<!DOCTYPE html>
<html lang="ko">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>AI-STEAM 교육 실험 보고서</title>
   <style>
       /* 기본 스타일 */
       body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; background-color: #f4f7f6; color: #333; }
       h1 { color: #2c3e50; margin-bottom: 30px; }
       
       /* 주요 레이아웃 컨테이너: 실험 결과와 보고서 작성 영역을 포함 */
       .main-container {
           display: flex;
           gap: 20px;
           width: 95%;
           max-width: 1800px; /* 두 개의 주요 섹션을 수용하기 위해 최대 너비 증가 */
           align-items: flex-start;
       }

       /* 왼쪽 섹션: 과학 실험 결과 표시 영역 */
       .science-experiment-section {
           flex: 0 0 40%; /* 전체 너비의 40% 차지 */
           display: flex;
           flex-direction: column;
           gap: 15px;
           padding: 20px;
           box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
           background-color: #fff;
           border-radius: 8px;
       }

       /* 오른쪽 섹션: 보고서 작성 영역 */
       .report-writing-section {
           flex: 1; /* 남은 공간 모두 차지 */
           display: flex;
           flex-direction: column;
           gap: 15px;
           padding: 20px;
           box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
           background-color: #fff;
           border-radius: 8px;
       }
       /* New: 인쇄 전용 스타일 (보고서 섹션만 인쇄되도록 설정) */
       @media print {
           body > *:not(.report-writing-section) {
               display: none !important; /* 보고서 섹션 외의 모든 요소 숨김 */
           }
           .report-writing-section {
               width: 100% !important;
               margin: 0 !important;
               padding: 0 !important;
               box-shadow: none !important;
               background-color: #fff !important;
               display: block !important;
               box-sizing: border-box;
           }
           .report-writing-section .report-section {
               border: none !important; /* 인쇄 시 테두리 제거 */
               box-shadow: none !important;
               padding: 0 15px !important; /* 인쇄 레이아웃을 위한 패딩 조정 */
           }
           .report-writing-section button {
               display: none !important; /* 인쇄 시 버튼 숨김 */
           }
           .report-section .image-entry-buttons {
               display: none !important; /* 인쇄 시 버튼 숨김 */
           }
           .report-section .input-area,
           .report-section .text-input-area,
           .report-section .image-input-area {
               border: none !important; /* 인쇄 시 입력 필드 테두리 제거 */
               padding: 0 !important;
               min-height: auto !important;
           }
           .report-section h3, .report-section h4 {
               margin-right: 0 !important; /* 버튼이 없을 경우 제목 옆 공간 제거 */
           }

           /* 인쇄를 위한 새로운 이미지 항목 레이아웃 스타일 */
           .report-section .image-entry {
               border: none !important; /* 인쇄 시 테두리 제거 */
               padding: 0 !important;
               margin-bottom: 10px !important; /* 인쇄를 위한 더 작은 마진 */
           }
           .report-section .image-entry .image-wrapper,
           .report-section .image-entry .image-description {
               border: none !important;
               padding: 0 !important;
               min-height: auto !important;
           }
           /* 드래그 오버 클래스 숨김 */
           .report-section .image-entry.drag-over {
               border: none !important;
           }
           .report-section .image-input-area .image-item {
               border: none !important;
               padding: 0 !important;
               margin: 0 !important;
           }
       }


       /* 공통 패널 스타일 */
       .panel {
           padding: 20px;
           border: 1px solid #e0e0e0;
           border-radius: 8px;
           background-color: #fff;
           box-sizing: border-box;
           display: flex;
           flex-direction: column;
           overflow: hidden;
       }
       
       /* 과학 실험 섹션 내 특정 패널 스타일 */
       .button-area, .data-collection-table-area, .line-graph-area, .data-stats-area {
           box-shadow: none; /* 부모 요소에 그림자가 있으면 중복 그림자 제거 */
           border: 1px solid #e0e0e0; /* 이미지에 따른 테두리 추가 */
       }
       
       .button-area {
           display: flex;
           flex-wrap: wrap;
           gap: 10px;
           justify-content: center;
           align-items: center;
       }

       .data-collection-table-area, .line-graph-area, .data-stats-area {
           flex-grow: 1; /* 사용 가능한 높이를 차지하도록 허용 */
           min-height: 200px; /* 시각화를 위한 최소 높이 */
       }
       
       .data-collection-table-area {
           /* height: 400px; /* 테이블의 고정 높이 (필요에 따라 조정) */ /* REMOVED FOR FLEXIBILITY */
       }

       /* 보고서 작성 섹션 스타일 */
       .report-section {
           border: 1px solid #ccc;
           border-radius: 5px;
           padding: 15px;
           margin-bottom: 15px;
           background-color: #f9f9f9;
       }
       .report-section h3, .report-section h4 {
           margin-top: 0;
           color: #444;
           display: inline-block; /* 버튼이 제목 옆에 오도록 허용 */
           margin-right: 10px; /* 제목과 버튼 사이 간격 */
       }
       .report-section .input-area, .report-section .text-input-area {
           border: 1px solid #ddd;
           padding: 10px;
           min-height: 50px;
           background-color: #fff;
           border-radius: 4px;
           cursor: text;
           white-space: pre-wrap; /* 공백 유지 및 줄바꿈 허용 */
       }
       .report-section .image-input-area {
           border: 1px dashed #bbb;
           padding: 20px;
           min-height: 100px;
           /* 버튼/콘텐츠 레이아웃 일관성을 위해 flex로 변경 */
           display: flex; 
           flex-direction: column; /* 버튼과 이미지 항목을 세로로 쌓음 */
           align-items: flex-start; /* 콘텐츠를 시작점에 정렬 */
           color: #888;
           background-color: #fff;
           border-radius: 4px;
           gap: 15px; /* 버튼과 이미지 항목/아이템 사이 간격 */
       }
       /* 개별 이미지 항목에 대한 스타일 (그래프에 사용됨) */
       .report-section .image-input-area .image-item {
            display: block; /* 그래프 이미지가 표시되도록 보장 */
            position: relative;
            margin: 0; /* 부모 gap으로 관리 */
            border: 1px solid #ddd;
            padding: 5px;
            border-radius: 5px;
            max-width: 100%;
            box-sizing: border-box; /* 패딩과 테두리를 너비에 포함 */
            align-self: center; /* 부모가 flex-column일 경우 이미지 항목을 가운데 정렬 */
       }
       .report-section .image-input-area .image-item img {
           max-width: 100%;
           height: auto;
           display: block; /* 이미지 아래 추가 공간 제거 */
       }

       /* NEW: 이미지 및 설명 레이아웃을 위한 스타일 */
       .report-section .image-entry {
           display: flex; 
           flex-direction: column; /* 이미지 및 설명, 버튼들을 세로로 쌓음 */
           align-items: flex-start; /* 항목을 위쪽으로 정렬 */
           gap: 10px; /* 버튼 그룹과 이미지 컨텐츠 사이 간격 */
           margin: 0; /* 부모 gap으로 관리 */
           border: 1px solid #eee; /* 각 이미지 항목의 연한 테두리 */
           padding: 10px;
           border-radius: 5px;
           background-color: #fcfcfc;
           width: 100%; /* 부모 내에서 전체 너비 차지 */
           box-sizing: border-box;
       }
       /* NEW: 이미지와 설명이 나란히 배치될 컨테이너 */
       .report-section .image-entry .image-content-row {
           display: flex;
           align-items: flex-start;
           gap: 15px; /* 이미지와 설명 사이 간격 */
           width: 100%;
       }

       .report-section .image-entry .image-wrapper {
           flex: 0 0 70%; /* 이미지가 너비의 70% 차지 */
           max-width: 70%;
           display: flex;
           justify-content: center; /* 래퍼 내에서 이미지 가운데 정렬 */
           align-items: center;
           border: 1px solid #ddd;
           padding: 5px;
           border-radius: 4px;
           background-color: #fff;
           box-sizing: border-box;
           position: relative; /* 이제 버튼은 여기에 있지 않음 */
       }
       .report-section .image-entry img {
           max-width: 100%;
           height: auto;
           display: block;
           border-radius: 3px;
       }
       .report-section .image-entry .image-description {
           flex: 0 0 30%; /* 설명이 너비의 30% 차지 */
           min-width: 30%; /* 최소 너비 추가 */
           border: 1px solid #ddd;
           padding: 10px;
           min-height: 80px; /* 설명 영역의 최소 높이 */
           background-color: #fff;
           border-radius: 4px;
           cursor: text;
           white-space: pre-wrap;
           box-sizing: border-box;
           word-wrap: break-word; /* 긴 단어 줄바꿈 보장 */
       }
       /* NEW: 이미지 항목 내 버튼 그룹 스타일 (설명 입력 칸 위로 이동) */
       .report-section .image-entry .image-entry-buttons {
           display: flex; /* 버튼들을 가로로 정렬 */
           gap: 5px; /* 버튼 사이 간격 */
           /* width: 100%; /* 부모 너비에 맞춤 */ /* flex-start로 정렬되어 필요 없음 */
           justify-content: flex-end; /* 버튼을 오른쪽으로 정렬 */
           margin-bottom: 5px; /* 버튼 그룹 아래 간격 */
           align-self: flex-end; /* 전체 image-entry 내에서 오른쪽 정렬 */
       }
       .report-section .image-entry .image-entry-buttons button {
           background-color: rgba(0, 0, 0, 0.5); /* 어두운 반투명 배경 */
           color: white;
           border: none;
           border-radius: 3px; /* 살짝 둥근 모서리 */
           width: 25px;
           height: 25px;
           font-size: 14px;
           font-weight: bold;
           cursor: pointer;
           display: flex;
           align-items: center;
           justify-content: center;
           transition: background-color 0.2s ease;
           padding: 0; /* 버튼 내부 패딩 제거 */
           margin: 0; /* 버튼 외부 마진 제거 */
       }
       .report-section .image-entry .image-entry-buttons button:hover {
           background-color: rgba(0, 0, 0, 0.7);
       }
       .report-section .image-entry .image-entry-buttons button:disabled {
           background-color: rgba(128, 128, 128, 0.5); /* 비활성화 시 회색 */
           cursor: not-allowed;
       }
       /* 삭제 버튼만 빨간색으로 유지 */
       .report-section .image-entry .image-entry-buttons .delete-image-button {
            background-color: rgba(255, 0, 0, 0.7);
       }
       .report-section .image-entry .image-entry-buttons .delete-image-button:hover {
            background-color: rgba(255, 0, 0, 1);
       }
       /* New: 이미지 다운로드 시 버튼 숨김 */
       .hide-for-capture {
           display: none !important;
       }


       /* 컨트롤 (원래 HTML에서 가져옴) */
       .controls { display: flex; gap: 20px; margin-bottom: 0; padding: 0; background-color: transparent; box-shadow: none; align-items: center; flex-wrap: wrap; justify-content: center; }
       button { padding: 12px 25px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; transition: background-color 0.3s ease, transform 0.2s ease; }
       button:hover { transform: translateY(-2px); }
       #connectButton { background-color: #28a745; color: white; } /* 장치 연결 버튼 */
       #disconnectButton { background-color: #dc3545; color: white; display: none; } /* 연결 해제 버튼 */
       #startButton { background-color: #007bff; color: white; } /* 시작 버튼 */
       #stopButton { background-color: #ffc107; color: #333; } /* 정지 버튼 */
       #resetButton { background-color: #6c757d; color: white; } /* 초기화 버튼 */
       button:disabled { background-color: #cccccc; cursor: not-allowed; } /* 비활성화된 버튼 */
       .slider-container { display: flex; align-items: center; gap: 10px; font-weight: bold; color: #555; }
       /* 슬라이더 스타일 */
       #tableRowCountSlider, #graphXAxisSlider { width: 150px; cursor: pointer; } 
       /* 슬라이더 값 표시 스타일 */
       #tableRowCountValue, #graphXAxisValue { min-width: 30px; text-align: right; }
       .controls-group { display: flex; align-items: center; gap: 10px; }
       .controls-group input[type="number"] { width: 70px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
       .controls-group label { font-weight: bold; }
       
       /* -- Main Layout Container -- (원래 HTML에서 가져옴, 대부분 .main-container로 대체) */
       .data-layout-container { display: none; /* 이전 레이아웃 컨테이너 숨김 */ }

       /* -- Panel Styles (Shared) -- (원래 HTML에서 가져옴, 대부분 대체/수정) */
       .panel {
           box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
           background-color: #fff;
           border-radius: 8px;
           padding: 20px;
           box-sizing: border-box;
           display: flex;
           flex-direction: column;
           overflow: hidden;
       }

       /* 차트 및 테이블 높이 (원래 HTML에서 가져옴) */
       .chart-container {
           width: 100%;
           height: 100%; /* 부모 차트 내부 패널의 전체 높이 차지 */
           display: flex;
           align-items: center;
           justify-content: center;
           position: relative;
       }
       .chart-container canvas { width: 100% !important; height: 100% !important; }
       
       .table-container {
           width: 100%;
           height: 100%; /* Changed: Removed fixed height, let it be flexible within its parent */
           overflow-y: auto; /* Enable scrolling if content exceeds height */
           -ms-overflow-style: none;
           scrollbar-width: none;
       }
       .table-container::-webkit-scrollbar {
           display: none;
       }
       table {
           width: 100%;
           border-collapse: collapse;
           margin-top: 15px;
           table-layout: fixed;
       }
       .stats-table {
           margin-top: 0;
           width: 100%;
       }
       th, td { 
           padding: 12px 15px; 
           text-align: center;
           border-bottom: 1px solid #eee; 
       }
       th { background-color: #e9ecef; color: #495057; font-weight: bold; }
       th[contenteditable="true"] { cursor: text; outline: 2px solid transparent; transition: outline 0.1s ease-in-out; }
       th[contenteditable="true"]:hover { outline: 2px solid #a0c4ff; }
       th[contenteditable="true"]:focus { outline: 2px solid #007bff; }
       tr:nth-child(even) { background-color: #f8f9fa; }
       tr:hover { background-color: #e2f0ff; }
       
       /* 게이지 차트 세부 사항 (원래 HTML에서 가져옴) */
       .gauge-label {
           position: absolute;
           font-size: 2.5rem;
           font-weight: bold;
           color: #333;
           top: 65%;
           left: 50%;
           transform: translate(-50%, -50%);
       }
       
       /* 새 레이아웃에 맞게 차트별 패널에 추가됨 */
       .line-graph-panel-inner, .bar-graph-panel-inner, .gauge-graph-panel-inner {
           height: 100%;
           width: 100%;
           display: flex;
           flex-direction: column;
           padding: 20px;
       }

   </style>
   <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-gauge@1.0.1"></script>
   <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>
   <h1>AI-STEAM 교육 실험 보고서</h1>

   <div class="main-container">
       <div class="science-experiment-section">
           <h2>이지메이커 데이터 대시보드</h2>

           <div class="panel button-area">
               <div class="controls">
                   <button id="connectButton">장치 연결</button> <button id="disconnectButton" style="display: none;">연결 해제</button> <button id="startButton" disabled>시작</button> <button id="stopButton" disabled>정지</button> <button id="resetButton" disabled>초기화</button> <div class="controls-group">
                       <input type="checkbox" id="manualScaleToggle"> <label for="manualScaleToggle">Y축 수동 설정</label>
                       <div id="manualScaleInputs" style="display: none;"> 최소: <input type="number" id="yMinInput" value="0">
                           최대: <input type="number" id="yMaxInput" value="1024">
                       </div>
                   </div>
               </div>
           </div>


           <div class="panel data-collection-table-area">
               <div class="slider-container">
                   <h4>데이터 현황</h4>
                   &nbsp;&nbsp;&nbsp; 표시 행: <span id="tableRowCountValue">5</span> <input type="range" id="tableRowCountSlider" min="0" max="50" step="1" value="5">
               </div>
               <div class="table-container">
                   <table id="dataTable">
                       <thead id="dataTableHead">
                           <tr>
                               <th>순번</th>
                               <th>시각</th>
                           </tr>
                       </thead>
                       <tbody id="dataTableBody"></tbody>
                   </table>
               </div>
           </div>


           <div class="panel line-graph-area">
               <div class="slider-container">
                   <h4>데이터 그래프 </h4>
                   &nbsp;&nbsp;&nbsp; X축 표시: <span id="graphXAxisValue">20</span> <input type="range" id="graphXAxisSlider" min="1" max="100" step="1" value="20"> &nbsp;&nbsp;&nbsp;<button id="sendLineGraphToReport">보고서 삽입</button> </div>
               <div class="chart-container">
                   <canvas id="lineChartCanvas"></canvas> </div>
           </div>

       <div class="panel data-two-area">
               <div style="display: flex; justify-content: space-around; margin-top: 1px; flex-wrap: wrap; gap: 10px; height: 300px;">
                   <div style="flex: 1; min-width: 200px; height: 80%; border: 1px solid #eee; border-radius: 8px; background-color: #fff; padding: 10px; box-sizing: border-box;">
                       <h4>최근 데이터&nbsp;&nbsp;&nbsp; <button id="sendBarGraphToReport">보고서 삽입</button></h4> 
   		<div class="chart-container">
                           <canvas id="barChartCanvas"></canvas>
                       </div>
                   </div>
                   <div style="flex: 1; min-width: 200px; height: 80%; border: 1px solid #eee; border-radius: 8px; background-color: #fff; padding: 10px; box-sizing: border-box;">
                       <h4 id="gaugeChartTitle">(센서1) &nbsp;&nbsp;&nbsp; <button id="sendGaugeChartToReport">보고서 삽입</button></h4>
   		    <div class="chart-container">
                           <canvas id="gaugeChartCanvas"></canvas>
                           <div id="gaugeLabel" class="gauge-label">0</div> </div>
                   </div>
               </div>
           </div>

           <div class="panel data-stats-area">
               <table id="statsTable" class="stats-table">
                   <thead>
                       <tr>
                           <th>항목</th>
                           <th>수집 갯수</th>
                           <th>최근</th>
                           <th>평균</th>
                           <th>최대</th>
                           <th>최소</th>
                       </tr>
                   </thead>
                   <tbody id="statsTableBody">
                   </tbody>
               </table>
   	</div>




       </div>

       <div class="report-writing-section" id="reportWritingSection">
 
          <h2>실험보고서 &nbsp;&nbsp;&nbsp; <button id="saveReportButton">보고서 저쟝</button></h2> 

		<img src="sc01_01.png"  style="max-width:100%; height:auto; display:block; margin-bottom: 10px;">
		<img src="sc01_02.png"  style="max-width:100%; height:auto; display:block; margin-bottom: 10px;">
		<img src="sc01_03.png"  style="max-width:100%; height:auto; display:block; margin-bottom: 10px;">

           <div class="report-section">
               <h3>실제 실험 모습 (사진 등)</h3>
               <div class="image-input-area" id="experimentImageArea">
                   <button id="insertLocalImageButton">이미지 삽입</button> <input type="file" id="localImageInput" accept="image/*" style="display: none;"> </div>
           </div>

           <div class="report-section">
               <h3>실험 데이터 및 그래프</h3>
               <div class="image-input-area" id="experimentResultGraphArea">
		실험 그래프의 보고서 삽입 버튼을 누르면 실험 결과 그래프가 삽입됩니다.
	       
	       </div>
           </div>

           <div class="report-section">
               <h3>실험 결과 해석</h3>
               <div contenteditable="true" class="text-input-area">텍스트 입력 영역</div>
           </div>

           <div class="report-section">
               <h3>알게 된 사실 및 결론</h3>
               <div contenteditable="true" class="text-input-area">텍스트 입력 영역</div>
           </div>

		<img src="sc01_04.png"  style="max-width:100%; height:auto; display:block; margin-bottom: 10px;">

       </div>
   </div>
   
   <script>
       // DOM 요소들을 JavaScript 변수에 할당
       const connectButton = document.getElementById('connectButton');
       const disconnectButton = document.getElementById('disconnectButton');
       const startButton = document.getElementById('startButton');
       const stopButton = document.getElementById('stopButton');
       const resetButton = document.getElementById('resetButton'); // New: 초기화 버튼 추가

       // 슬라이더 요소들
       const tableRowCountSlider = document.getElementById('tableRowCountSlider');   // 테이블 행 수 슬라이더
       const tableRowCountValue = document.getElementById('tableRowCountValue');     // 테이블 행 수 값 표시
       const graphXAxisSlider = document.getElementById('graphXAxisSlider');         // 그래프 X축 데이터 수 슬라이더
       const graphXAxisValue = document.getElementById('graphXAxisValue');           // 그래프 X축 데이터 수 값 표시

       const manualScaleToggle = document.getElementById('manualScaleToggle');
       const manualScaleInputs = document.getElementById('manualScaleInputs');
       const yMinInput = document.getElementById('yMinInput');
       const yMaxInput = document.getElementById('yMaxInput');
       const dataTableHead = document.getElementById('dataTableHead');
       const dataTableBody = document.getElementById('dataTableBody');
       const statsTableBody = document.getElementById('statsTableBody');
       const lineChartCanvas = document.getElementById('lineChartCanvas');
       const barChartCanvas = document.getElementById('barChartCanvas');
       const gaugeChartCanvas = document.getElementById('gaugeChartCanvas');
       const gaugeLabel = document.getElementById('gaugeLabel');
       const gaugeChartTitle = document.getElementById('gaugeChartTitle');
       const experimentResultGraphArea = document.getElementById('experimentResultGraphArea');
       const insertLocalImageButton = document.getElementById('insertLocalImageButton');
       const localImageInput = document.getElementById('localImageInput');
       const experimentImageArea = document.getElementById('experimentImageArea');
       const reportWritingSection = document.getElementById('reportWritingSection'); // 인쇄를 위해 추가됨

       // "결과 전송" 버튼들
       const sendLineGraphToReportButton = document.getElementById('sendLineGraphToReport');
       const sendBarGraphToReportButton = document.getElementById('sendBarGraphToReport');
       const sendGaugeChartToReportButton = document.getElementById('sendGaugeChartToReport');

       // New: "보고서 저장" (인쇄) 버튼 -> "보고서 이미지 다운로드"로 변경
       const saveReportButton = document.getElementById('saveReportButton');


       let port; // 시리얼 포트 객체
       let reader; // 시리얼 포트 리더 객체
       let reading = false; // 데이터 읽기 루프 제어 플래그
       
       // 슬라이더로 조절되는 값들
       let tableRowLimit = parseInt(tableRowCountSlider.value);   // 테이블에 표시될 최대 행 수
       let graphDataLimit = parseInt(graphXAxisSlider.value);     // 그래프에 표시될 최대 데이터 포인트 수

       let sequenceNumber = 1; // 데이터 순번
       let sensorCount = 0; // 센서 개수
       let sensorData = []; // 모든 수집 데이터를 저장하여 누적 통계 계산
       let sensorNames = []; // 사용자 정의 센서 이름을 저장할 배열
       
       let lineChart; // 꺾은선 차트 객체
       let barChart; // 막대 차트 객체
       let gaugeChart; // 게이지 차트 객체
       
       // 꺾은선 차트의 색상 팔레트
       let lineChartColors = [
           'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)', 'rgb(255, 205, 86)',
           'rgb(153, 102, 255)', 'rgb(201, 203, 207)', 'rgb(255, 159, 64)', 'rgb(120, 180, 50)'
       ];

       // Chart.js 인스턴스 초기화 함수
       function initCharts() {
           if (lineChart) lineChart.destroy(); // 기존 라인 차트가 있으면 제거
           if (barChart) barChart.destroy(); // 기존 막대 차트가 있으면 제거
           if (gaugeChart) gaugeChart.destroy(); // 기존 게이지 차트가 있으면 제거

           // 라인 차트 초기화 (데이터셋은 동적으로 추가됨)
           lineChart = new Chart(lineChartCanvas, {
               type: 'line',
               data: {
                   labels: [], // x축 라벨
                   datasets: [] // 데이터셋 (센서별로 추가됨)
               },
               options: {
                   responsive: true, // 반응형
                   maintainAspectRatio: false, // 가로세로 비율 유지 안함
                   animation: false, // 애니메이션 비활성화
                   scales: {
                       x: {
                           title: { display: true, text: '수집 시각' } // x축 제목
                       },
                       y: {
                           title: { display: true, text: '데이터' }, // y축 제목
                           beginAtZero: true, // y축 0부터 시작
                       }
                   },
                   plugins: {
                       legend: {
                           display: true, // 범례 표시
                           position: 'top' // 범례 위치
                       }
                   }
               }
           });

           // 막대 그래프 초기화
           barChart = new Chart(barChartCanvas, {
               type: 'bar',
               data: {
                   labels: [], // x축 라벨 (센서 이름)
                   datasets: [{
                       label: '최근 입력 데이터',
                       data: [],
                       backgroundColor: [],
                       borderColor: [],
                       borderWidth: 1
                   }]
               },
               options: {
                   responsive: true,
                   maintainAspectRatio: false,
                   animation: false,
                   plugins: {
                       legend: {
                           display: false
                       } // 범례 숨김
                   },
                   scales: {
                       x: {
                           title: { display: true, text: '센서' } // x축 제목
                       },
                       y: {
                           title: { display: true, text: '데이터' }, // y축 제목
                           beginAtZero: true,
                       }
                   }
               }
           });

           // 게이지 차트 초기화 (도넛 차트 활용)
           gaugeChart = new Chart(gaugeChartCanvas, {
               type: 'doughnut',
               data: {
                   labels: ['Current', 'Remaining'],
                   datasets: [{
                       data: [0, 1024], // [현재 값, 남은 값]
                       backgroundColor: ['rgb(0, 150, 136)', 'rgb(220, 220, 220)'],
                       borderWidth: 0
                   }]
               },
               options: {
                   responsive: true,
                   maintainAspectRatio: false,
                   circumference: 180, // 반원 형태
                   rotation: 270, // 시작 각도
                   cutout: '50%', // 가운데 구멍 크기
                   plugins: {
                       legend: {
                           display: false
                       }, // 범례 숨김
                       tooltip: {
                           enabled: false
                       } // 툴팁 숨김
                   }
               }
           });
           applyChartScaleSettings(); // 초기 스케일 설정 적용
       }

       // 테이블 헤더 업데이트 함수 (센서 개수에 따라 동적 생성)
       function updateTableHeader(count) {
           // sensorCount가 0일 때 (초기화 또는 첫 데이터 수신) 헤더를 완전히 재생성
           if (sensorCount !== count || sensorCount === 0) {
               // sensorNames 배열 초기화 또는 크기 조정
               if (sensorNames.length !== count) {
                   const oldNames = [...sensorNames];
                   sensorNames = Array(count).fill(null).map((_, i) => oldNames[i] || `센서${i + 1}`);
               }

               // 실시간 데이터 테이블 헤더
               const dataHeaderRow = dataTableHead.querySelector('tr');
               // 기존 센서 헤더 제거
               while (dataHeaderRow.children.length > 2) {
                   dataHeaderRow.removeChild(dataHeaderRow.lastChild);
               }
               // 새 센서 헤더 추가
               sensorNames.forEach((name, i) => {
                   const newHeader = document.createElement('th');
                   newHeader.textContent = name;
                   newHeader.setAttribute('contenteditable', 'true'); // 내용 편집 가능하게 설정
                   newHeader.dataset.sensorIndex = i; // 나중에 참조를 위해 인덱스 저장
                   newHeader.addEventListener('blur', handleSensorNameEdit); // 편집 완료 시 이벤트 리스너
                   newHeader.addEventListener('keydown', (e) => {
                       if (e.key === 'Enter') {
                           e.preventDefault(); // contenteditable에서 새 줄 방지
                           e.target.blur(); // 변경 사항 저장을 위해 blur 트리거
                       }
                   });
                   dataHeaderRow.appendChild(newHeader);
               });

               // 통계 테이블 바디 (각 센서에 대한 행 재생성)
               statsTableBody.innerHTML = ''; // 이전 행 지우기
               sensorNames.forEach((name, i) => {
                   const newRow = statsTableBody.insertRow();
                   newRow.innerHTML = `
                       <td>${name}</td>
                       <td id="stats-count-${i}">0</td>
                       <td id="stats-latest-${i}">---</td>
                       <td id="stats-avg-${i}">---</td>
                       <td id="stats-max-${i}">---</td>
                       <td id="stats-min-${i}">---</td>
                   `;
               });
               sensorCount = count; // 계산을 위한 sensorData 배열 초기화
               sensorData = Array.from({
                   length: sensorCount
               }, () => []);
           }
       }

       // 센서 이름 편집 처리 함수
       function handleSensorNameEdit(event) {
           const index = parseInt(event.target.dataset.sensorIndex);
           const newName = event.target.textContent.trim();

           if (newName && sensorNames[index] !== newName) {
               sensorNames[index] = newName;
               console.log(`Sensor ${index + 1} name changed to: ${newName}`);

               // 라인 차트 범례 업데이트
               if (lineChart && lineChart.data.datasets[index]) {
                   lineChart.data.datasets[index].label = newName;
               }
               // 막대 차트 라벨 업데이트
               if (barChart && barChart.data.labels[index] !== undefined) {
                   barChart.data.labels[index] = newName;
               }
               // 통계 테이블 행 라벨 업데이트
               const statsRow = statsTableBody.rows[index];
               if (statsRow) {
                   statsRow.cells[0].textContent = newName;
               }
               // 첫 번째 센서에 대한 게이지 차트 제목 업데이트
               if (index === 0) {
                   gaugeChartTitle.textContent = `게이지 차트 (${newName})`;
               }

               lineChart.update();
               barChart.update();
               gaugeChart.update(); // 제목 변경 반영을 위해 게이지 차트 업데이트 (데이터와 직접 관련 없지만)
           } else if (!newName) {
               // 사용자가 이름을 지우면 기본값으로 되돌림
               event.target.textContent = sensorNames[index];
           }
       }

       // Y축 스케일 설정 적용 함수
       function applyChartScaleSettings() {
           const yMin = parseFloat(yMinInput.value);
           const yMax = parseFloat(yMaxInput.value);

           if (manualScaleToggle.checked && !isNaN(yMin) && !isNaN(yMax)) {
               lineChart.options.scales.y.min = yMin;
               lineChart.options.scales.y.max = yMax;
               barChart.options.scales.y.min = yMin;
               barChart.options.scales.y.max = yMax;
               console.log(`Y-axis scale manually set to [${yMin}, ${yMax}]`);
           } else {
               delete lineChart.options.scales.y.min;
               delete lineChart.options.scales.y.max;
               delete barChart.options.scales.y.min;
               delete barChart.options.scales.y.max;
               console.log('Y-axis scale reverted to auto mode');
           }

           const gaugeMaxValue = manualScaleToggle.checked ? yMax : 1024;
           gaugeChart.data.datasets[0].data[1] = gaugeMaxValue - gaugeChart.data.datasets[0].data[0];

           lineChart.update('none'); // 애니메이션 없이 업데이트
           barChart.update('none'); // 애니메이션 없이 업데이트
           gaugeChart.update('none'); // 애니메이션 없이 업데이트
       }


       // 통계 데이터 계산 및 업데이트 함수
       function updateStatsTable(dataValues) {
           dataValues.forEach((value, index) => {
               // 누적 배열에 데이터 추가
               if (!sensorData[index]) {
                   sensorData[index] = [];
               }
               sensorData[index].push(value); // 이미 숫자로 변환된 값 사용

               const data = sensorData[index];
               const count = data.length;
               const latest = data[data.length - 1];
               const sum = data.reduce((a, b) => a + b, 0);
               const avg = sum / count;
               const max = Math.max(...data);
               const min = Math.min(...data);

               // 통계 테이블 업데이트
               document.getElementById(`stats-count-${index}`).textContent = count;
               document.getElementById(`stats-latest-${index}`).textContent = latest.toFixed(2);
               document.getElementById(`stats-avg-${index}`).textContent = avg.toFixed(2);
               document.getElementById(`stats-max-${index}`).textContent = max.toFixed(2);
               document.getElementById(`stats-min-${index}`).textContent = min.toFixed(2);
           });
       }

       // 테이블 행 수 슬라이더 값 변경 시 이벤트 리스너
       tableRowCountSlider.addEventListener('input', (event) => {
           tableRowLimit = parseInt(event.target.value);
           tableRowCountValue.textContent = tableRowLimit;

           if (tableRowLimit === 0) {
               dataTableBody.innerHTML = ''; // 테이블 내용 모두 지움
           } else {
               while (dataTableBody.children.length > tableRowLimit) {
                   dataTableBody.removeChild(dataTableBody.lastChild); // 맨 아래에서 제거
               }
           }
       });

       // 그래프 X축 데이터 슬라이더 값 변경 시 이벤트 리스너
       graphXAxisSlider.addEventListener('input', (event) => {
           graphDataLimit = parseInt(event.target.value);
           graphXAxisValue.textContent = graphDataLimit;

           // 라인 차트 데이터셋 길이 조절
           lineChart.data.labels = lineChart.data.labels.slice(-graphDataLimit);
           lineChart.data.datasets.forEach(dataset => {
               dataset.data = dataset.data.slice(-graphDataLimit);
           });
           lineChart.update('none'); // 애니메이션 없이 업데이트
       });


       // 수동 Y축 스케일 토글 이벤트
       manualScaleToggle.addEventListener('change', () => {
           manualScaleInputs.style.display = manualScaleToggle.checked ? 'flex' : 'none';
           applyChartScaleSettings();
       });

       // 수동 Y축 입력 필드 변경 이벤트
       yMinInput.addEventListener('change', applyChartScaleSettings);
       yMaxInput.addEventListener('change', applyChartScaleSettings);


       // 장치 연결 버튼 클릭 이벤트
       connectButton.addEventListener('click', async () => {
           try {
               // 시리얼 포트 선택 요청
               port = await navigator.serial.requestPort();
               await port.open({
                   baudRate: 9600
               }); // 9600 보율로 포트 열기

               connectButton.style.display = 'none'; // 연결 버튼 숨기기
               disconnectButton.style.display = 'inline-block'; // 연결 해제 버튼 보이기
               startButton.disabled = false; // 시작 버튼 활성화
               resetButton.disabled = false; // 초기화 버튼 활성화 (New: 초기화 버튼도 활성화)
               console.log('Serial port connected.');

               // 데이터를 지속적으로 읽기 시작
               reading = true;
               readLoop();

           } catch (error) {
               console.error('시리얼 포트 연결 실패:', error);
               alert('시리얼 포트 연결에 실패했습니다. 장치가 올바르게 연결되어 있는지 확인해주세요.');
           }
       });

       // 연결 해제 버튼 클릭 이벤트
       disconnectButton.addEventListener('click', async () => {
           if (reader) {
               await reader.cancel(); // 읽기 작업 취소
           }
           if (port) {
               await port.close(); // 포트 닫기
           }

           reading = false;
           connectButton.style.display = 'inline-block'; // 연결 버튼 보이기
           disconnectButton.style.display = 'none'; // 연결 해제 버튼 숨기기
           startButton.disabled = true; // 시작 버튼 비활성화
           stopButton.disabled = true; // 정지 버튼 비활성화
           resetButton.disabled = true; // 초기화 버튼 비활성화
           console.log('Serial port disconnected.');
       });


       // 데이터 읽기 루프
       async function readLoop() {
           while (port.readable && reading) {
               reader = port.readable.getReader();
               try {
                   while (true) {
                       const {
                           value,
                           done
                       } = await reader.read();
                       if (done) {
                           // Reader has been canceled.
                           break;
                       }
                       const textDecoder = new TextDecoder();
                       const lines = textDecoder.decode(value).split('\n'); // 라인별로 분리
                       lines.forEach(line => {
                           if (line.trim().length > 0) { // 빈 라인 건너뛰기
                               processData(line.trim()); // 데이터 처리
                           }
                       });
                   }
               } catch (error) {
                   console.error('시리얼 읽기 오류:', error);
               } finally {
                   reader.releaseLock();
               }
           }
       }

       // 데이터 처리 함수
       function processData(dataString) {
           console.log("수신 데이터:", dataString);
           const parts = dataString.split(',').map(s => s.trim()); // 콤마로 분리, 공백 제거

           if (parts.length < 2) {
               console.warn("유효하지 않은 데이터 형식:", dataString);
               return;
           }

           const time = new Date().toLocaleTimeString(); // 현재 시각
           const dataValues = parts.slice(1).map(Number).filter(n => !isNaN(n)); // 숫자 데이터만 추출

           if (dataValues.length === 0) {
               console.warn("유효한 숫자 데이터가 없습니다:", dataString);
               return;
           }

           // 센서 개수 업데이트 (초기화 또는 변경 감지)
           if (sensorCount !== dataValues.length) {
               updateTableHeader(dataValues.length);
               // 새 센서가 추가되면 차트 데이터셋도 업데이트
               lineChart.data.datasets = [];
               barChart.data.datasets[0].data = [];
               barChart.data.datasets[0].backgroundColor = [];
               barChart.data.datasets[0].borderColor = [];
               barChart.data.labels = [];

               sensorNames.forEach((name, i) => {
                   lineChart.data.datasets.push({
                       label: name,
                       data: [],
                       borderColor: lineChartColors[i % lineChartColors.length],
                       tension: 0.1,
                       fill: false
                   });
                   barChart.data.labels.push(name);
                   barChart.data.datasets[0].backgroundColor.push(lineChartColors[i % lineChartColors.length]);
                   barChart.data.datasets[0].borderColor.push(lineChartColors[i % lineChartColors.length].replace('rgb', 'rgba').replace(')', ', 1)'));
               });
               lineChart.update('none');
               barChart.update('none');
           }


           // 테이블에 새 행 추가
           const newRow = dataTableBody.insertRow(0); // 맨 위에 새 행 추가
           const sequenceCell = newRow.insertCell(0);
           const timeCell = newRow.insertCell(1);

           sequenceCell.textContent = sequenceNumber++;
           timeCell.textContent = time;

           dataValues.forEach((value, index) => {
               const dataCell = newRow.insertCell(index + 2);
               dataCell.textContent = value.toFixed(2); // 소수점 두 자리까지 표시

               // 꺾은선 차트 데이터 추가
               if (lineChart.data.datasets[index]) {
                   lineChart.data.datasets[index].data.push(value);
               }
           });

           // 테이블 행 수 제한
           while (dataTableBody.children.length > tableRowLimit) {
               dataTableBody.removeChild(dataTableBody.lastChild);
           }


           // 라인 차트 X축 라벨 추가 (하나만 추가)
           if (lineChart.data.labels.length === 0 || lineChart.data.labels[lineChart.data.labels.length - 1] !== time) {
               lineChart.data.labels.push(time);
           }

           // 라인 차트 데이터셋 길이 조절
           if (lineChart.data.labels.length > graphDataLimit) {
               lineChart.data.labels = lineChart.data.labels.slice(-graphDataLimit);
               lineChart.data.datasets.forEach(dataset => {
                   dataset.data = dataset.data.slice(-graphDataLimit);
               });
           }
           lineChart.update('none');


           // 막대 그래프 데이터 업데이트 (가장 최근 값 사용)
           barChart.data.datasets[0].data = dataValues;
           barChart.update('none');

           // 게이지 차트 업데이트 (첫 번째 센서 데이터 사용)
           if (dataValues.length > 0) {
               const gaugeValue = dataValues[0];
               const gaugeMaxValue = manualScaleToggle.checked ? parseFloat(yMaxInput.value) : 1024;
               gaugeChart.data.datasets[0].data = [gaugeValue, gaugeMaxValue - gaugeValue];
               gaugeLabel.textContent = gaugeValue.toFixed(2);
               gaugeChart.update('none');
           }

           // 통계 테이블 업데이트
           updateStatsTable(dataValues);

           // 시작/정지 버튼 상태 업데이트 (데이터가 들어오면 정지 버튼 활성화 가능)
           stopButton.disabled = false;
       }


       // 시작 버튼
       startButton.addEventListener('click', () => {
           // 시리얼 포트가 연결되어 있지 않으면 경고
           if (!port || !port.readable) {
               alert('먼저 장치를 연결해주세요.');
               return;
           }
           reading = true;
           startButton.disabled = true;
           stopButton.disabled = false;
           readLoop(); // 데이터 읽기 루프 다시 시작
       });

       // 정지 버튼
       stopButton.addEventListener('click', async () => {
           reading = false;
           startButton.disabled = false;
           stopButton.disabled = true;
           if (reader) {
               await reader.cancel(); // 읽기 작업 취소
           }
           console.log('Data collection stopped.');
       });

       // 초기화 버튼
       resetButton.addEventListener('click', () => {
           // 데이터 초기화 로직
           sequenceNumber = 1;
           sensorData = Array.from({
               length: sensorCount
           }, () => []); // 센서 데이터 초기화
           dataTableBody.innerHTML = ''; // 테이블 내용 초기화
           statsTableBody.innerHTML = ''; // 통계 테이블 내용 초기화

           // 차트 데이터 초기화
           lineChart.data.labels = [];
           lineChart.data.datasets.forEach(dataset => {
               dataset.data = [];
           });
           lineChart.update('none');

           barChart.data.labels = [];
           barChart.data.datasets[0].data = [];
           barChart.update('none');

           gaugeChart.data.datasets[0].data = [0, manualScaleToggle.checked ? parseFloat(yMaxInput.value) : 1024];
           gaugeLabel.textContent = '0';
           gaugeChart.update('none');

           // 초기 테이블 헤더 다시 그림 (센서 이름은 유지)
           updateTableHeader(sensorCount); // 기존 센서 개수로 헤더 다시 그림

           startButton.disabled = false; // 시작 버튼 다시 활성화
           stopButton.disabled = true; // 정지 버튼 비활성화
           console.log('All data reset.');
       });


       // 보고서 이미지 삽입
       insertLocalImageButton.addEventListener('click', () => {
           localImageInput.click(); // 숨겨진 input[type="file"] 클릭
       });

       localImageInput.addEventListener('change', (event) => {
           const file = event.target.files[0];
           if (file) {
               const reader = new FileReader();
               reader.onload = (e) => {
                   addImageToReport(experimentImageArea, e.target.result);
               };
               reader.readAsDataURL(file);
           }
       });

       // 보고서에 이미지 추가 함수
       function addImageToReport(targetArea, imageDataUrl, description = '') {
           const imageEntry = document.createElement('div');
           imageEntry.classList.add('image-entry');

           // 이미지 및 설명 컨테이너
           const imageContentRow = document.createElement('div');
           imageContentRow.classList.add('image-content-row');

           const imageWrapper = document.createElement('div');
           imageWrapper.classList.add('image-wrapper');
           const img = document.createElement('img');
           img.src = imageDataUrl;
           imageWrapper.appendChild(img);

           const imageDescription = document.createElement('div');
           imageDescription.classList.add('image-description');
           imageDescription.contentEditable = true;
           imageDescription.textContent = description || '이미지에 대한 설명을 입력하세요.';

           imageContentRow.appendChild(imageWrapper);
           imageContentRow.appendChild(imageDescription);

           // 버튼 그룹 (삭제, 위로, 아래로)
           const buttonGroup = document.createElement('div');
           buttonGroup.classList.add('image-entry-buttons');

           const moveUpButton = document.createElement('button');
           moveUpButton.textContent = '▲';
           moveUpButton.classList.add('move-up-button');
           moveUpButton.title = '위로 이동';
           moveUpButton.addEventListener('click', () => moveImageEntry(imageEntry, -1));

           const moveDownButton = document.createElement('button');
           moveDownButton.textContent = '▼';
           moveDownButton.classList.add('move-down-button');
           moveDownButton.title = '아래로 이동';
           moveDownButton.addEventListener('click', () => moveImageEntry(imageEntry, 1));

           const deleteButton = document.createElement('button');
           deleteButton.textContent = '✖';
           deleteButton.classList.add('delete-image-button');
           deleteButton.title = '삭제';
           deleteButton.addEventListener('click', () => {
               if (confirm('이 이미지를 삭제하시겠습니까?')) {
                   targetArea.removeChild(imageEntry);
                   updateButtonStates(targetArea); // 버튼 상태 업데이트
               }
           });

           buttonGroup.appendChild(moveUpButton);
           buttonGroup.appendChild(moveDownButton);
           buttonGroup.appendChild(deleteButton);

           imageEntry.appendChild(buttonGroup); // 버튼 그룹 먼저 추가
           imageEntry.appendChild(imageContentRow); // 이미지 내용 추가

           // 파일 입력 버튼 바로 뒤에 이미지 삽입 (또는 끝에 추가)
           const insertButton = targetArea.querySelector('#insertLocalImageButton');
           if (insertButton) {
               targetArea.insertBefore(imageEntry, insertButton.nextSibling);
           } else {
               targetArea.appendChild(imageEntry);
           }
           updateButtonStates(targetArea); // 버튼 상태 업데이트
       }

       // 이미지 항목 이동 함수
       function moveImageEntry(entry, direction) {
           const parent = entry.parentNode;
           const siblings = Array.from(parent.children).filter(child => child.classList.contains('image-entry'));
           const currentIndex = siblings.indexOf(entry);
           const newIndex = currentIndex + direction;

           if (newIndex >= 0 && newIndex < siblings.length) {
               const referenceNode = siblings[newIndex];
               if (direction === -1) { // 위로 이동
                   parent.insertBefore(entry, referenceNode);
               } else { // 아래로 이동
                   parent.insertBefore(entry, referenceNode.nextSibling);
               }
               updateButtonStates(parent); // 버튼 상태 업데이트
           }
       }

       // 버튼 상태 업데이트 (첫/마지막 항목에 따라 비활성화)
       function updateButtonStates(area) {
           const imageEntries = Array.from(area.querySelectorAll('.image-entry'));
           imageEntries.forEach((entry, index) => {
               const moveUpButton = entry.querySelector('.move-up-button');
               const moveDownButton = entry.querySelector('.move-down-button');

               if (moveUpButton) moveUpButton.disabled = (index === 0);
               if (moveDownButton) moveDownButton.disabled = (index === imageEntries.length - 1);
           });
       }

       // 차트 이미지를 보고서에 삽입하는 일반 함수
       async function sendChartToReport(chartCanvas, targetArea, descriptionText) {
           // 차트 생성 버튼들을 일시적으로 숨김
           const buttonsToHide = document.querySelectorAll('.report-writing-section button, .image-entry-buttons button, .slider-container button');
           buttonsToHide.forEach(btn => btn.classList.add('hide-for-capture'));

           await html2canvas(chartCanvas, {
               useCORS: true, // 크로스 오리진 이미지 로드 허용 (필요시)
               scale: 2, // 고해상도 캡처
               logging: false // 콘솔 로깅 비활성화
           }).then(canvas => {
               const imageDataURL = canvas.toDataURL('image/png');
               addImageToReport(targetArea, imageDataURL, descriptionText);
               alert('차트 이미지가 보고서에 삽입되었습니다.');
           }).catch(error => {
               console.error('차트 이미지를 생성하는 데 실패했습니다:', error);
               alert('차트 이미지를 보고서에 삽입하는 데 실패했습니다. 다시 시도해주세요.');
           }).finally(() => {
               // Show buttons again, regardless of success or failure
               buttonsToHide.forEach(btn => btn.classList.remove('hide-for-capture'));
           });
       }


       // 라인 그래프를 보고서에 삽입
       sendLineGraphToReportButton.addEventListener('click', () => {
           sendChartToReport(lineChartCanvas, experimentResultGraphArea, '실험 데이터 꺾은선 그래프');
       });

       // 바 그래프를 보고서에 삽입
       sendBarGraphToReportButton.addEventListener('click', () => {
           sendChartToReport(barChartCanvas, experimentResultGraphArea, '센서별 최근 데이터 막대 그래프');
       });

       // 게이지 차트를 보고서에 삽입
       sendGaugeChartToReportButton.addEventListener('click', () => {
           sendChartToReport(gaugeChartCanvas, experimentResultGraphArea, '주요 센서 게이지 차트');
       });

       // 보고서 저장 (이미지로 다운로드)
       saveReportButton.addEventListener('click', async () => {
           // 인쇄를 위해 보고서 섹션 외의 모든 요소를 숨깁니다.
           // html2canvas는 display: none 요소를 캡처하지 않습니다.
           const buttonsToHide = document.querySelectorAll('.report-writing-section button');
           buttonsToHide.forEach(btn => btn.classList.add('hide-for-capture'));

           const originalBodyOverflow = document.body.style.overflow;
           document.body.style.overflow = 'visible'; // 스크롤바가 이미지에 포함되지 않도록 설정

           await html2canvas(reportWritingSection, {
               useCORS: true,
               scale: 2,
               logging: false,
               windowWidth: reportWritingSection.scrollWidth, // 전체 너비 캡처
               windowHeight: reportWritingSection.scrollHeight // 전체 높이 캡처
           }).then(canvas => {
               const imageDataURL = canvas.toDataURL('image/png');

               // 다운로드를 위한 임시 링크 생성
               const a = document.createElement('a');
               a.href = imageDataURL;
               a.download = '실험보고서.png'; // 다운로드될 파일 이름
               document.body.appendChild(a);
               a.click(); // 클릭 이벤트를 트리거하여 다운로드 시작
               document.body.removeChild(a); // 임시 링크 제거
               console.log('실험보고서 이미지가 다운로드되었습니다.');
           }).catch(error => {
               console.error('보고서 이미지를 생성하는 데 실패했습니다:', error);
               alert('보고서 이미지를 다운로드하는 데 실패했습니다. 다시 시도해주세요.');
           }).finally(() => {
               // Show buttons again, regardless of success or failure
               buttonsToHide.forEach(btn => btn.classList.remove('hide-for-capture'));
           });
       });


       // 페이지 로드 시 초기 설정
       window.addEventListener('load', () => {
           initCharts(); // 차트 초기화
           // Ensure table header is initialized even with 0 sensors initially
           updateTableHeader(0); 

           // Initialize slider values on load
           tableRowCountValue.textContent = tableRowCountSlider.value;
           graphXAxisValue.textContent = graphXAxisSlider.value;

           // 드래그 앤 드롭 이벤트 리스너 제거됨 (더 이상 필요 없음)
           // 대신, 초기 로드 시 기존 이미지 항목이 있다면 버튼 상태를 업데이트
       });

   </script>
</body>
</html>
